extern func __main();

extern func InitWindow(width: int, height: int, title: char*);
extern func CloseWindow();
extern func SetTargetFPS(fps: int);
extern func GetFrameTime(): real;
extern func WindowShouldClose(): bool;
extern func BeginDrawing();
extern func EndDrawing();

extern func ClearBackground(color: int);

extern func TextFormat(text: char*, args: int): char*;
extern func TextLength(text: char*): int;
extern func MeasureText(text: char*, fontSize: int): int;

extern func DrawFPS(posX: int, posY: int);
extern func DrawText(text: char*, posX: int, posY: int, fontSize: int, color: int);
extern func DrawPixel(posX: int, posY: int, color: int);
extern func DrawLine(startPosX: int, startPosY: int, endPosX: int, endPosY: int, color: int);
extern func DrawRectangle(posX: int, posY: int, width: int, height: int, color: int);

extern func IsKeyUp(key: int): bool;
extern func IsKeyDown(key: int): bool;
extern func IsKeyPressed(key: int): bool;
extern func IsKeyReleased(key: int): bool;

extern func SetRandomSeed(seed: int); 
extern func GetRandomValue(min: int, max: int): int;

int SCREEN_WIDTH  = 438;
int SCREEN_HEIGHT = 778;

int GRID_WIDTH  = 10;
int GRID_HEIGHT = 20;

int GRID_X = 48;
int GRID_Y = 48;

int BLOCK_SIZE = 32;

int BLACK  = 0xFF140800;
int WHITE  = 0xFFFFFFFF;
int YELLOW = 0xFF00C3FF;
int GOLD   = 0xFFA0D6FF;

int KEY_RIGHT = 262;
int KEY_LEFT  = 263;
int KEY_DOWN  = 264;
int KEY_UP    = 265;
int KEY_SPACE = 32;

int STROKE_COLOR = 0xFF663500;
int STROKE_WIDTH = 2;

func DrawGrid() do
    int v_lines = GRID_WIDTH + 1;
    int h_lines = GRID_HEIGHT + 1;

    int v_lineLength = GRID_HEIGHT * BLOCK_SIZE + h_lines * STROKE_WIDTH;
    int h_lineLength = GRID_WIDTH * BLOCK_SIZE + v_lines * STROKE_WIDTH;

    int startX = GRID_X;
    int endY = GRID_Y + v_lineLength;

    for i to v_lines do
        for line to STROKE_WIDTH do
            startX += 1;
            DrawLine(startX, GRID_Y, startX, endY, STROKE_COLOR);
        end
        startX += BLOCK_SIZE;
    end

    int startY = GRID_Y;
    int endX = GRID_X + h_lineLength;

    for i to h_lines do
        for line to STROKE_WIDTH do
            startY += 1;
            DrawLine(GRID_X, startY, endX, startY, STROKE_COLOR);
        end
        startY += BLOCK_SIZE;
    end
end

func DrawBlock(i: int, j: int, color: int) do
    int x = GRID_X + STROKE_WIDTH + i * (BLOCK_SIZE + STROKE_WIDTH);
    int y = GRID_Y + STROKE_WIDTH + j * (BLOCK_SIZE + STROKE_WIDTH);
    DrawRectangle(x, y, BLOCK_SIZE, BLOCK_SIZE, color);
end

func DrawPiece(piece: int*, color: int) do
    for i to 4 do
        int index = piece[i];
        int x = index % GRID_WIDTH;
        int y = index / GRID_WIDTH;
        DrawBlock(x, y, color);
    end
end

func DrawBoard(board: int*) do
    for j to GRID_HEIGHT do
        int dj = j * GRID_WIDTH;
        for i to GRID_WIDTH do
            if board[dj + i] != 0 then
                DrawBlock(i, j, board[dj + i]);
            end
        end
    end
end

func InitBoard(board: int*) do
    int size = GRID_WIDTH * GRID_HEIGHT;
    for i to size do
        board[i] = 0;
    end
end

func InitPiece(piece: int*): int do
    int r = GetRandomValue(1, 7);

    if r == 1 then
        piece[0] = 0;
        piece[1] = 1;
        piece[2] = 2;
        piece[3] = 3;
        return r;
    end
    if r == 2 then
        piece[0] = 0;
        piece[1] = 1;
        piece[2] = GRID_WIDTH + 1;
        piece[3] = GRID_WIDTH;
        return r;
    end
    if r == 3 then
        piece[0] = 0;
        piece[1] = 2;
        piece[2] = 1;
        piece[3] = GRID_WIDTH + 1;
        return r;
    end
    if r == 4 then
        piece[0] = 0;
        piece[1] = 2;
        piece[2] = 1;
        piece[3] = GRID_WIDTH + 2;
        return r;
    end
    if r == 5 then
        piece[0] = 0;
        piece[1] = 2;
        piece[2] = 1;
        piece[3] = GRID_WIDTH;
        return r;
    end
    if r == 6 then
        piece[0] = 1;
        piece[1] = 2;
        piece[2] = GRID_WIDTH + 1;
        piece[3] = GRID_WIDTH;
        return r;
    end
    if r == 7 then
        piece[0] = 0;
        piece[1] = 1;
        piece[2] = GRID_WIDTH + 1;
        piece[3] = GRID_WIDTH + 2;
        return r;
    end

    return r;
end

func PlacePiece(board: int*, piece: int*, color: int) do
    board[piece[0]] = color;
    board[piece[1]] = color;
    board[piece[2]] = color;
    board[piece[3]] = color;

    InitPiece(piece);
end

func CanMovePieceDown(board: int*, piece: int*): bool do
    for j to 4 do
        int i = piece[j];
        if i / GRID_WIDTH + 1 >= GRID_HEIGHT then
            return false;
        end
        if board[i + GRID_WIDTH] != 0 then
            return false;
        end
    end
    return true;
end

func CanMovePieceLeft(board: int*, piece: int*): bool do
    for j to 4 do
        int i = piece[j];
        if i % GRID_WIDTH <= 0 then
            return false;
        end
        if board[i - 1] != 0 then
            return false;
        end
    end
    return true;
end

func CanMovePieceRight(board: int*, piece: int*): bool do
    for j to 4 do
        int i = piece[j];
        if i % GRID_WIDTH + 1 >= GRID_WIDTH then
            return false;
        end
        if board[i + 1] != 0 then
            return false;
        end
    end
    return true;
end

func MovePieceDown(piece: int*) do
    piece[0] += GRID_WIDTH;
    piece[1] += GRID_WIDTH;
    piece[2] += GRID_WIDTH;
    piece[3] += GRID_WIDTH;
end

func MovePieceLeft(piece: int*) do
    piece[0] -= 1;
    piece[1] -= 1;
    piece[2] -= 1;
    piece[3] -= 1;
end

func MovePieceRight(piece: int*) do
    piece[0] += 1;
    piece[1] += 1;
    piece[2] += 1;
    piece[3] += 1;
end

func CanRotateCw(board: int*, piece: int*): bool do
    int cx = piece[2] % GRID_WIDTH;
    int cy = piece[2] / GRID_WIDTH;
    for i to 4 do
        int x = piece[i] % GRID_WIDTH;
        int y = piece[i] / GRID_WIDTH;

        int dx = -y + cy + cx;
        int dy = x - cx + cy;

        if dx < 0 || dx >= GRID_WIDTH || dy < 0 || dy >= GRID_HEIGHT then
            return false;
        end

        if board[dy * GRID_WIDTH + dx] != 0 then
            return false;
        end
    end
    return true;
end

func RotateCw(piece: int*) do
    int cx = piece[2] % GRID_WIDTH;
    int cy = piece[2] / GRID_WIDTH;
    for i to 4 do
        int x = piece[i] % GRID_WIDTH;
        int y = piece[i] / GRID_WIDTH;

        int dx = -y + cy + cx;
        int dy = x - cx + cy;

        piece[i] = dy * GRID_WIDTH + dx;
    end
end

func CheckLine(board: int*, dj: int): bool do
    for i to GRID_WIDTH do
        if board[dj + i] == 0 then
            return false;
        end
    end
    return true;
end

func ClearLine(board: int*, line: int) do
    int dj = line * GRID_WIDTH;
    for i to GRID_WIDTH do
        board[dj + i] = 0;
    end
    int j = line - 1;
    while j >= 0 do
        dj = j * GRID_WIDTH;
        for i to GRID_WIDTH do
            int color = board[dj + i];
            board[dj + i] = 0;
            board[dj + i + GRID_WIDTH] = color;
        end
        j -= 1;
    end
end

func ClearLines(board: int*): int do
    int lines = 0;
    for j to GRID_HEIGHT do
        if CheckLine(board, j * GRID_WIDTH) then
            ClearLine(board, j);
            j -= 1;
            lines += 1;
        end
    end
    return lines;
end

func main(): int do
    __main();
    
    int[200] board;
    int[004] piece;

    InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "TetraminÃ³s");
    SetTargetFPS(120);

    InitBoard(board);
    InitPiece(piece);

    int points = 0;

    real moveDownCooldown = 0.0;
    real moveSideCooldown = 0.0;
    int lastMoveH = 0;
    bool isFastMoving = false;
    bool isSideMoving = false;

    while WindowShouldClose() == false do
        real dt = GetFrameTime();
        moveDownCooldown += dt;

        int lines = 0;

        if IsKeyPressed(KEY_SPACE) then
            while CanMovePieceDown(board, piece) do
                MovePieceDown(piece);
            end

            PlacePiece(board, piece, YELLOW);
            lines += ClearLines(board);

            moveDownCooldown = 0.0;
        end

        if moveDownCooldown > 1.0 || (IsKeyDown(KEY_DOWN) && moveDownCooldown > 0.05) then
            if CanMovePieceDown(board, piece) then
                MovePieceDown(piece);
                moveDownCooldown = 0.0;
            end
        end

        if moveDownCooldown > 0.5 && CanMovePieceDown(board, piece) == false then
            PlacePiece(board, piece, YELLOW);
            lines += ClearLines(board);
        end

        if lines > 0 then
            points += (lines * 100) + (100 * 1 << (lines - 2));
        end

        int moveH = 0;
        if IsKeyDown(KEY_RIGHT) then moveH += 1; end
        if IsKeyDown(KEY_LEFT) then moveH -= 1; end

        if moveH == 0 || moveH != lastMoveH then
            isFastMoving = false;
            isSideMoving = false;
            moveSideCooldown = 0.0;
        end

        if isSideMoving then
            moveSideCooldown += dt;

            if moveSideCooldown > 0.17 then
                isFastMoving = true;
            end
        end

        if moveH > 0 then
            if isSideMoving == false || IsKeyPressed(KEY_RIGHT) then
                if CanMovePieceRight(board, piece) then
                    MovePieceRight(piece);
                end
                isSideMoving = true;
            end
            
            if isFastMoving && moveSideCooldown > 0.05 then
                if CanMovePieceRight(board, piece) then
                    MovePieceRight(piece);
                end
                moveSideCooldown = 0.0;
            end
        end

        if moveH < 0 then
            if isSideMoving == false || IsKeyPressed(KEY_LEFT) then
                if CanMovePieceLeft(board, piece) then
                    MovePieceLeft(piece);
                end
                isSideMoving = true;
            end
            
            if isFastMoving && moveSideCooldown > 0.05 then
                if CanMovePieceLeft(board, piece) then
                    MovePieceLeft(piece);
                end
                moveSideCooldown = 0.0;
            end
        end

        lastMoveH = moveH;

        if IsKeyPressed(KEY_UP) then
            if CanRotateCw(board, piece) then
                RotateCw(piece);
            end
        end

        BeginDrawing();
        ClearBackground(BLACK);
        DrawGrid();
        DrawBoard(board);
        DrawPiece(piece, GOLD);
        DrawFPS(10, 10);

        char* pointsText = TextFormat("Points: %d", points);
        int pointsTextSize = MeasureText(pointsText, 20);
        int pointsPosX = SCREEN_WIDTH - pointsTextSize - 10;
        DrawText(pointsText, pointsPosX, 10, 20, WHITE);
        
        EndDrawing();
    end

    CloseWindow();

    return 0;
end
